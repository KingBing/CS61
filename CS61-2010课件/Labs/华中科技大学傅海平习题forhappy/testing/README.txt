实现内存分配算法
本题目的主要目的在于考察你的 C 语言程序设计能力. 你需要在两天之内按步骤完成下面
要求的内容, 并对你所作的事情进行记录. 按照我们的设计, 你不一定有足够的时间完成
下面的每一项任务, 所以不必紧张. 你最后需要提交至少一个程序, 一份设计文档和一份
报告. 你可以参考你能找到的任何资料, 但是在你提交的报告和程序中必须加以注明.

1. D. E. Knuth 在 1973 年提出了一种基于 boundary tags 的分配算法. 查找该算法的原始出处;

计算机程序设计艺术第一卷：基本算法第三版英文版(p441-P442)

2. 你将收到一份 Harvard 大学 CS61 课程的 ppt ("动态内存分配"一章), 看这个 ppt
   之后用尽量精确的语言描述这个算法(针对 malloc 的情形);
	该课程描述的算法采用了隐式链表的方法管理空闲内存块，所谓隐式链表，即链表本身并没有提供
	指向左右节点的指针，而是依靠各个内存块节点在物理上的毗邻特性来表示空闲内存块的逻辑关系，
	同时也没有任何数据结构来记录空闲块和已分配块位置及其它信息。
	课程所描述的算法采用了边界标志法分配内存，每个节点块都有一个头部和尾部标志，
	而且头部和尾部通常是相同的，该标志记录了每个块的分配情况，
	算法的关键是如何分配内存块以及如何回收合并被释放的块，算法的优点是实现起来简单，
	分配时间开销为O(n)，即线性时间增长，而回收合并空闲块的开销为O(1),即常量时间，
	而内存利用率则取决与放置策略，放置策略通常是首先适配法(first-fit)，下次适配法(next-fit)，
	最佳适配法(best-fit)，最坏适配法(worst- fit)，但是该算法致命的弱点就是需要线性时间进行内存分配，
	随着空闲块的链表长度越来越长，分配的时间开销将变大，因此在时间应用中需要一定的权衡。

3. 在你的报告中用 200 字左右聊一聊 Knuth 这个人物;

    Donald E. Knuth，1938年出生于威斯康星州（Wisconsin）。1960年，当他毕业于凯斯理工学院（Case Institute of Technology）数学系时，因为成绩过于出色，被校方打破历史惯例，同时授予学士和硕士学位。他随即进入大名鼎鼎的加州理工学院数学系，仅用三年时间便取得博士学位，此时年仅25岁。
    毕业后留校任助理教授，28岁时升为副教授。30岁时，加盟斯坦福大学计算机系，任正教授。从31岁那年起，他开始出版他的历史性经典巨著：The Art of Computer Programming。他计划共写7卷，然而仅仅出版三卷之后，已经震惊世界，使他获得计算机科学界的最高荣誉Turing Award，此时，他年仅36岁。后来，此书与牛顿的“自然哲学的数学原理”等一起，被评为“世界历史上最伟大的十种科学著作”之一。相信学过数据结构和编译原理的同学们都知道KMP算法和LR(K)算法有多么不可思议，然而此书中这样的算法比比皆是！
　　在计算机科学上，他主要是一位理论家。然而，他在理论以外也同样做出惊人的成就。鼎鼎大名的排版软件Tex，就是他的作品。此外，还有Metafont等，也在世界上得到广泛使用。
　　他的其它著作和论文难以数计，其中包括Concrete Mathematics等名著。从1977年起，他获得Fletcher Jones Professor of Computer Science的头衔，并且同时兼任Professor of Electrical Engineering。
　　1990年，斯坦福大学更授予他一个非同寻常的头衔Professor of The Art of Computer Science，作为对他的特殊贡献的承认！
　　他的其它荣誉数不胜数，其中主要的有：美国国家科学院院士，美国艺术与科学院院士，美国工程院院士，法国科学院外籍院士，挪威科学院外籍院士......；美国数学会Steele奖，瑞典皇家科学院Adelskold奖，以色列工学院Harvey 奖，IEEE冯诺依曼奖，东京高科技奖...... 共达数十个之多。同时，他还是牛津大学等二十几所大学的荣誉博士。早在1970年，他就在国际数学大会上做过特邀报告。
　　Knuth获得图灵奖时为36岁，他是历史上最年轻的图灵奖获得者，甚至有可能永远把这个记录保持下去。相比之下，其他获得图灵奖的人当时一般都是五十几岁或者六十几岁(例如去年的姚先生，和刚去世的Simon)，可见Knuth有多伟大！他真不愧为大师中的大师！
　　Knuth很早就提前退休，为的是集中精力把巨著The Art of Computer Programming写完。他一生共带过二十四个(此数字也许不准)博士生，发誓不会再带更多的学生。但是，他有一个奇妙的承诺：在他定期进行的讲座中，会不断提出一些新的难题。如果有人能在给定的期限内解出任何一道难题，他将为那个人的博士论文签名(大约相当于名誉导师吧)！不知道世界之大，有没有哪位后起之秀能获得这样的殊誉？!

4. 你将收到一份源码, 和一份指南, 你需要按照指南的要求修改 mm.c, 实现其中的
   mm_init, mm_malloc, mm_free. 你不用实现 mm_realloc. 具体要求参考CS61 课程. 你首
   先需要实现上述基于 boundary tags 的分配算法.

4.1 在动手写代码之前, 你要写一份设计文档. 提示: 为了不让你后面的工作陷入困境, 
    这份文档应该写得尽可能详细. 我们对这份文档的格式没有要求.

4.2 在 mm.c 中实现上述算法. 你的代码要有详细的注释. 实现这个算法大约需要 200 行代码.

4.3 按照 writeup 的指示对你的实现进行评分, 对于你得分较高/较低的项目, 简单的分析原因.

5. 完成下面几件任务中的至少一件:

5.1 在 mm.c 中实现 slab 分配器;

5.2 找一个内存分配器的代码, 将它加以修改用于 mm.c 中, 让你的总分达到 60, 或者让
    某个测试的得分达到 100. 你的实现必须能通过 config.h 中原有的所有测试项目;

5.3 设计一个新的内存分配器, 详细的描述你使用的算法和数据结构, 仔细估算它能得多
    少分; 实现这个分配器, 使总分至少达到 50. 实际得分和你估算的是否一致? 为何会产生
    差距?

你最好在 Linux 或者 Unix 平台上完成这些任务. 如果你坚持使用 Windows, 建议你使用
Cygwin. 否则你需要自己设置编译和运行的环境. 虽然这不是很困难.

你可以修改 config.h 中的 MAX_HEAP.

我们将在 Intel Core Due 2 E4500 2.2GHz + 2GB 物理内存, Linux 2.6.24.4 + glibc
2.6.1 的测试平台上运行你的程序.如果这和你的环境不同, 你最好评估一下你的得分会不
会发生很大变化.

你需要在你提交的报告中明确指出你在收到这份题目后所进行的所有相关活动, 包括查阅
资料, 详细设计, 编码, 调试等以及它们花费的时间.

