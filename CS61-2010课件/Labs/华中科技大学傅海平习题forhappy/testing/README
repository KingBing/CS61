实现内存分配算法

本题目的主要目的在于考察你的 C 语言程序设计能力. 你需要在两天之内按步骤完成下面
要求的内容, 并对你所作的事情进行记录. 按照我们的设计, 你不一定有足够的时间完成
下面的每一项任务, 所以不必紧张. 你最后需要提交至少一个程序, 一份设计文档和一份
报告. 你可以参考你能找到的任何资料, 但是在你提交的报告和程序中必须加以注明.

1. D. E. Knuth 在 1973 年提出了一种基于 boundary tags 的分配算法. 查找该算法的原始出处;

2. 你将收到一份 Harvard 大学 CS61 课程的 ppt ("动态内存分配"一章), 看这个 ppt
   之后用尽量精确的语言描述这个算法(针对 malloc 的情形);

3. 在你的报告中用 200 字左右聊一聊 Knuth 这个人物;

4. 你将收到一份源码, 和一份指南, 你需要按照指南的要求修改 mm.c, 实现其中的
   mm_init, mm_malloc, mm_free. 你不用实现 mm_realloc. 具体要求参考CS61 课程. 你首
   先需要实现上述基于 boundary tags 的分配算法.

4.1 在动手写代码之前, 你要写一份设计文档. 提示: 为了不让你后面的工作陷入困境, 
    这份文档应该写得尽可能详细. 我们对这份文档的格式没有要求.

4.2 在 mm.c 中实现上述算法. 你的代码要有详细的注释. 实现这个算法大约需要 200 行代码.

4.3 按照 writeup 的指示对你的实现进行评分, 对于你得分较高/较低的项目, 简单的分析原因.

5. 完成下面几件任务中的至少一件:

5.1 在 mm.c 中实现 slab 分配器;

5.2 找一个内存分配器的代码, 将它加以修改用于 mm.c 中, 让你的总分达到 60, 或者让
    某个测试的得分达到 100. 你的实现必须能通过 config.h 中原有的所有测试项目;

5.3 设计一个新的内存分配器, 详细的描述你使用的算法和数据结构, 仔细估算它能得多
    少分; 实现这个分配器, 使总分至少达到 50. 实际得分和你估算的是否一致? 为何会产生
    差距?

你最好在 Linux 或者 Unix 平台上完成这些任务. 如果你坚持使用 Windows, 建议你使用
Cygwin. 否则你需要自己设置编译和运行的环境. 虽然这不是很困难.

你可以修改 config.h 中的 MAX_HEAP.

我们将在 Intel Core Due 2 E4500 2.2GHz + 2GB 物理内存, Linux 2.6.24.4 + glibc
2.6.1 的测试平台上运行你的程序.如果这和你的环境不同, 你最好评估一下你的得分会不
会发生很大变化.

你需要在你提交的报告中明确指出你在收到这份题目后所进行的所有相关活动, 包括查阅
资料, 详细设计, 编码, 调试等以及它们花费的时间.

